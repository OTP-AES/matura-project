\documentclass[12pt]{report}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{ {images/} }
\usepackage[
backend=biber,
style=numeric,
citestyle=numeric,
sorting=none]						
{biblatex}							
\addbibresource{mybib.bib}
\setlength{\parskip}{5mm}
%Are there any preferred bibliography style choices / general style requirements when it comes to the Maturaarbeit at the KSZ which I ought to implement?

% There are more or less none. Personally I like the notation where you use the
% first letter of the authors surname in square brackets. I think this is also
% the latex preset.  You are free to chose the notation you like most but use it
% consistently. Make sure you include all the information needed in the
% bibliography. If you cite web resources, make sure you include the date you
% retrieved the information. Try to avoid citing Wikipedia but use Wikipedia to
% find other, more credible sources.


\begin{document}

\title{OTP and AES: A historical transition between two systems of cryptography}
\author{Valdemar Thanner\\Kantonsschule Zug\\Supervised by Mr. Bernhard Keller\\Linguistic supervision by Ms. Margrit Oetiker}
\maketitle

\tableofcontents

\chapter{OTP: The One Time Pad}

\section{What is a "One Time Pad"?}
When speaking about OTP, it is important to distinguish between its two meanings: On the one hand, it is a technique used to encrypt information. This technique requires one single key, used both to encrypt and decrypt the information. This key is also referred to as a one time pad; therefore, it is important to distinguish between the one time pad (a cryptographical technique) and a one time pad (a key which is used to encrypt and decrypt information).

The One Time Pad is largely derived from the Vernam cipher, which is named after Gilbert Vernam. The Vernam cipher utilized a perforated tape (one of the earliest types of data storage) as the secret key\cite{VernamPatent}. Each bit of data was stored in the form of a hole punched into the perforated tape.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{PerforatedTape}
\caption{Perforated tape, utilized to store bits as punched holes}
\end{figure}

However, this system had a vulnerability which the One-Time Pad solved: In Vernam's original method, the perforated tape was not exchanged after it had completed one cycle; instead, it was looped around continuously, often being used to encrypt multiple different messages.

This made the entire system vulnerable. The re-usage of the key meant that the resulting ciphertext suffered from a so-called known-plaintext vulnerability \cite{HutSix}. This means that, if a plaintext and its corresponding ciphertext are captured, the key utilized to generate the ciphertext can be derived from them. This is not an issue if the key is exchanged each time a new message is encrypted. However, if the key of any Vernam cipher machine was compromised through a known-plaintext attack, any further intercepted ciphertexts could be decrypted.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{VernamCipher.jpg}
\caption{An image from Vernam's famous "Secret signaling system" patent of 1919.}
\end{figure}    

\section{Method used}
%This section, especially the practical example, is the most important part of the chapter.
In the following section, the utilized method will be clarified through usage of an example. In this example, the message \textit{"cryptography"} will first be encrypted by its sender, sent to its intended recipient, and finally decoded by the recipient.

\subsection{Generation of the random key}
In order to encrypt the plaintext, a key must first be generated. This key will be utilized to encrypt the plaintext through the usage of modular addition, turning it into the ciphertext.

This key must fulfil some crucial criteria \cite{MilsElectronic}. Foremost, the length of the key (the amount of  characters contained within it) must be equivalent to or greater than the length of the plaintext; otherwise, it is not possible to perform any encryption (using the OTP). Secondly, the key must be generated randomly. This is mainly due to the fact that a randomly generated key makes frequency analysis\cite{FrequencyAnalysis}, the form of cryptanalysis most commonly used to break classical ciphers, impossible.

% It's not clear what it means to generate a key randomly. 

The key consists of numbers. Usually, when the plaintext is made up of Latin letters, the numbers range between 0 and 25. The key can be converted into Latin letters through the same method applied to the plaintext outlined in the following chapter, however, this is not necessary, although the key is often transported in the form of text.

As the message being encrypted in this example has 12 characters, the key must also posses at least 12 characters. For the sake of this example, the key \textit{"sytruifgnihm"} will be utilized.

\subsection{Modular addition of the key and plaintext}
%unsure if a picture explaining modular addition and subtraction is needed, or if the provided explanation suffices?			

% In my opinition, the part about modular addition is quite clear. You could
% also add a binary example where you don't even need the concept of modular
% addition since all you need is an XOR gate - which of course is the same as
% modular addition of bits - but easier to understand.


Next, the ciphertext is created through modular addition of the key and the plaintext. This can be applied not only to a message consisting of alphabetical characters, but also to any sequence of bits. If the plaintext consists of a message made up of alphabetical characters, the plaintext and the key are added using arithmetic referred to as \textit{"addition modulo 26"}. The correct mathematical notation for modular arithmetic is $(a+b)\:mod\:c$, where c is referred to as the \textit{modulus}, which is the value that cannot be passed nor reached in modular addition. In order to perform modular addition, the variables a and b are first added, after which they are divided by the modulus c, up to an integer. The resulting remainder r is the final result of the operation.

Before the modular addition of the plaintext and the key can begin, each character (of the plaintext as well as of the secret key, in the case that the key was generated as a string of Latin letters instead of as a sequence of numbers) must be converted to a number, corresponding to it's position in the Latin alphabet:

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table1.PNG}		
\end{figure}
%Do these tables suffice in aiding understanding the example, or 		                                             should I include more "graphical" explanations as well?

% I don't think this needs to get any more graphical. You could look into latex
% tables and math syntax for arrow to make the typesetting look a bit more
% consistent.

As the key was also generated in the form of characters, it too must be converted to a sequence of numbers:

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table2.PNG}
\end{figure}

Afterwards, the key and the plaintext are added together utilizing modular addition. Of course, all operations below are performed in \textit{mod 26}. Finally, the resulting numbers are converted to the character to which they correspond in the Latin alphabet. The resulting sequence of characters is referred to as the ciphertext.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table3.PNG}
\end{figure}

The modular addition of the plaintext and the key can also, however, be performed bitwise. This simply means that, instead of adding a message consisting of (up to) 26 different letters with a key (also consisting of up to 26 different letters), we simply add the bits of the plaintext (a computer file consisting of bits), which can assume the value of either 1 or 2, with the bits of the key. The bits are added in modulo 2. This process is referred to as XOR, one of the basic bitwise operations which can be performed directly by a computers central processor.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{XORgate.PNG}
\caption{The formula used by an XOR gate.}
\end{figure}

\subsection{Decoding of the ciphertext using the key}
Assuming the message has been delivered to the intended recipient, who must hold a copy of the secret key (which, as OTP is a symmetrical cryptographical method, is identical to the one utilized to create the ciphertext), the recipient can now decode the ciphertext in order to view the plaintext.

Since the ciphertext was created through the modular addition of the plaintext and the key, the recipient can utilize modular subtraction in order to view the plaintext. In order to do this, the recipient must subtract the key from the ciphertext in modulo 26, and convert the resulting numbers to Latin characters.  However, it is now also necessary for the numbers not to become negative. Fortunately, this is also made possible by modular arithmetic, as the values simply loop back around from 0 as well. Once again, all below operations are in \textit{mod 26}.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table4.PNG}
\end{figure}

Now, the message's journey is complete, having passed from plaintext into ciphertext, being transported to its intended recipient in the form of ciphertext, and finally being decoded and read by its recipient. 

\section{Perfect secrecy: Information-theoretical security}
An important characteristic of OTP is that the ciphertext convey no information at all in regards to the plaintext; this means that it is not possible to garner any information about the key nor the plaintext if one is in possession of the ciphertext \cite{PerfectSecrecy} \cite{HandbookOfAppliedCryptography}.

From this, two other important characteristics of a cryptographical system with perfect secrecy can be derived. Firstly, perfect message indistinguishability. This means that, even if you are provided with multiple different plaintexts and one ciphertext, it is impossible to assign any one plaintext to the provided ciphertext. Secondly, if the key is the same length as the plaintext (as is the case in OTP), then there exists a key for every possible encryption from plaintext to ciphertext. This means that any plaintext can be converted to any ciphertext, making it impossible to determine the key without access to both the plaintext and the ciphertext. This is referred to as perfect key ambiguity.		%This paragraph was difficult for me to summarize well.

Although many believe that the ciphertext does provide information about the plaintext, namely its length, this can easily be solved through padding, where characters of no importance to the plaintext are added to it before encryption \cite{HutSix}.

\subsection{Mathematical proof}
%This is the section which was most difficult for me to write; I opted to present a more simplified explanation of %Shannons proof without the use of probability theory.
%Should I Include the probability Theory or is it better to keep it simple for the reader?

% I'm not convinced that you'll manage to present a mathematically correct proof without using
% any probability theory. There are a few problems with the current version of the proof: 


In 1949, Shannon proved the perfect secrecy of OTP by using probability theory \cite{ShannonOTP}. To be precise, he proved that, in order to achieve perfect secrecy, the key must possess at least the same length as the plaintext; one of the key characteristics of OTP. If this is the case, then an attacker cannot determine the plaintext given the ciphertext, even with access to infinite computational capacity; a "brute-force attack" is impossible.

% To proof that OTP provides perfect secrecy it's not enough to show that one
% can only achieve perfect secrecy with a key of the same length as the message
% as this is only a necessity but no sufficiency
% (https://en.wikipedia.org/wiki/Necessity_and_sufficiency) to achieve perfect
% secrecy. E.g. if I use the key consisting of as many zeros as the message has
% letters and encrypt every message by adding said key, the encryption gives you
% no secrecy at all even though the key has the same length as the message.


A simplified method of presenting this proof is as follows:

If the attacker does indeed possess infinite computational capacity, he can generate every possible key which could have been used to generate the ciphertext, and he can then generate every possible plaintext (each of which will correspond to the given ciphertext and one of the generated keys).

% I don't understand the comment in brackets. You could use a graphical explanation or mathematical
% notation to make your point clearer.

It follows that, if the ciphertext was $m$ bits long, there would be $2^m$ possible keys (or, in the case that the plaintext and ciphertext consist of Latin characters, $26^m$ possible keys). This is because a bit can possess the value of either 0 or 1, meaning that each individual bit of the key has two possible values. As The entire key possesses m bits, each cell must be multiplied by the following cell in order to obtain the total number of possible keys. In the case that the key consists of Latin characters, however, each cell possess 26 possible values (ranging from 0 to 25); therefore, the total number of possible keys would be $26^m$.

If the possible amount of keys that the attacker can generate is equal to $2^m$, and the attacker can generate one possible plaintext for each key, that means that the amount of plaintexts which the attacker can generate is also equal to $2^m$ (or, once again, in the case of Latin characters, equal to $26^m$ plaintexts).

This amount, $2^m$, is equal to the amount of possible bit sequences of the length m; therefore, the attacker cannot possibly eliminate any one possible plaintext of the length m, meaning that he cannot garner any information from the ciphertext on its own. This fulfils the requirements of perfect secrecy.

% We should discuss the above paragraphs in a meeting as I don't fully
% understand what you are trying to say. I'm not convinced that this suffices to
% proof perfect secrecy. Most importantly, it appears that you never used the
% randomness of the key in your proof. That's also the point where it gets
% difficult to avoid probability theory. Without probability theory you don't
% have a understanding of what it means for a key to be ``random''.

\subsection{Why can only OTP achieve perfect secrecy?}
%Not sure if this information warrants its own section or if I should merge it with the above one

From the above proof, it can be concluded that, in order for the elimination of any possible plaintext to be impossible (rendering a brute-force attack impossible), the key must possess at least the same length as the plaintext. Also, the individual bits of the must not be dependant on one another. These conditions are only fulfilled by OTP.  

\section{Issues with OTP}
%I had just one sentence here, but felt it appeared strange to just have one sentence and opted to leave it blank.
\subsection{True randomness in generating the key}
One of the most important aspects of the utilized key is that it must be completely random (see 1.2.1). However, generating a random sequence of numbers or letters is no trivial task. In fact, most random number generation functions of even modern programming languages are not adequately random for use in cryptography. This is especially difficult for computers, considering that a computer is, in essence, designed to follow a set of predictable instructions as quickly as possible.

Therefore, in order to generate a sufficiently random key, it is preferable to utilize hardware random number generators, for example by utilizing a true random noise source \cite{MilsElectronic}. One such example is the key generator built by mils electronic, where a set of parallel ring oscillators are sampled. Because the oscillation speed of each ring is influenced by random factors such as local variations in temperature and voltage.

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{MilsElectronic.PNG}
\caption{A hardware random number generator with sufficient randomness to be utilized in the generation of one-time pads.}
\end{figure}

\subsection{Secure distribution of the key itself}
The main issue in regards to OTP is that, while it posses perfect security, therefore solving the issue of safely transmitting the ciphertext, the problem instead becomes how to securely transmit the key to the intended recipient of the encrypted message.

Therefore, in order to ensure that the plaintext cannot be accessed by any party other than its intended recipient, the complete security of the transmittal of the key must also be ensured.

However, if the communicants already possess a method by which the key can be transmitted with infallible security, then it stands to reason that the plaintext itself could just as well be submitted through the same channel, considering that it has the same number of bytes (or characters) as the key. So, the problem of securely transmitting the plaintext has simply been transferred to the problem of securely transmitting the key.




One method of mitigating this issue is to first send one very long key, which can then be used for multiple messages in the future. Using this method, only one secure transmission has to be made in order to ensure the security of multiple transmissions. 

\subsection{Secure disposal of a utilized key}
%Once again, not entirely sure if this warrants its own section or if it should be merged into the above section.
After a key has been fully utilized, it has to be disposed of securely, in order to prevent any information from being compromised in the future, which is possible should the key continue to exist. Therefore, it is necessary to completely eradicate the entirety of the key. If the key was stored on a digital media, such as a USB drive or HDD, the only completely secure method of disposal is considered to be complete incineration.

% Whenever you use a sentence like ``is considered to be...'' you need to
% provide a source. Are you sure that incinerating hard drives does the job? The
% ways I know of used to destroy harddrives involve strong electromagnets and drills.

\chapter{AES: The Advanced Encryption Standard}

\section{AES viewed from a high level}

Viewed from a high level, the AES algorithm consists of one XOR step, followed by 10 rounds of cryptographical measures, with each round as well as the initial XOR step using a specific subkey, generated using the main key. By passing through these steps, each block of plaintext is converted into a block of Ciphertext. In the following chapter, each individual aspect of the complete AES algorithm will be more closely examined.

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{AES_fig1.jpg}
\caption{A high-level description of AES.}
\end{figure}

\section{Method used}

\subsection{Subkey generation (KEYEXPANSIONS)}
As can be seen in the high-level explanation, AES requires 11 128-bit subkeys (also referred to as round keys); one for the initial XOR operation, and then one for each of the 10 rounds. These subkeys are derived from the main key using the "Rijndael key schedule" \cite{KeySchedule}.

\subsection{Initial XOR operation}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{AES_fig2.jpg}
\end{figure}

This step is identical to the XOR operation already described in the chapter regarding AES; once again, a simple XOR gate is used to add the plaintext with the initial XOR operations own subkey (which, crucially, is not the main key itself, but is, in fact, derived from the main key during the process of subkey generation). After this, the resulting ciphertext proceeds into the first of ten so-called "rounds".

\subsection{Rounds}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{AES_fig3.jpg}
\end{figure}

\subsubsection{Substitution using lookup table (SUBBYTES)}
The first substitution is relatively simple to perform; this is because it is a bytewise operation. This means that the data being manipulated is one single byte. In this case, the manipulation is a substitution of each byte with another byte, the substitution being determined by a lookup table, in which each individual byte is assigned another byte with which it must be swapped. The reason that a lookup table is practical is that there are only $2^8 = 256$ different possible bytes. This means that the speed which could be gained from swapping bytes using a formula instead of a simple lookup table is inconsequential.

\subsubsection{Transposition (SHIFTROWS)}

\subsubsection{Substitution using formula (MIXCOLUMNS)}

\subsubsection{Round-closing XOR operation (ADDROUNDKEY)}

\section{Fulfilment of Shannon's properties}

\subsection{Diffusion}

\subsection{Confusion}

\section{Problems with AES}

\subsection{Overconfidence and over-reliance}

\subsection{Keeping of a shared secret}

% have to print the bibliography once all entries are made, otherwise an error keeps occuring. \printbibliography

\end{document}

