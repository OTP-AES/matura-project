\documentclass[12pt]{report}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{ {images/} }
\usepackage[
backend=biber,
style=numeric,
citestyle=numeric,
sorting=none]						
{biblatex}							
\addbibresource{mybib.bib}
\setlength{\parskip}{5mm}
\usepackage{mathtools}
%Are there any preferred bibliography style choices / general style requirements when it comes to the Maturaarbeit at the KSZ which I ought to implement?

% There are more or less none. Personally I like the notation where you use the
% first letter of the authors surname in square brackets. I think this is also
% the latex preset.  You are free to chose the notation you like most but use it
% consistently. Make sure you include all the information needed in the
% bibliography. If you cite web resources, make sure you include the date you
% retrieved the information. Try to avoid citing Wikipedia but use Wikipedia to
% find other, more credible sources.


\begin{document}

\title{OTP and AES: A historical transition between two systems of cryptography}
\author{Valdemar Thanner\\Kantonsschule Zug\\Supervised by Mr. Bernhard Keller\\Linguistic supervision by Ms. Margrit Oetiker}
\maketitle

\tableofcontents

\chapter{OTP: The One Time Pad}

\section{What is a "One Time Pad"?}
When speaking about OTP, it is important to distinguish between its two meanings: On the one hand, it is a technique used to encrypt information. This technique requires one single key, used both to encrypt and decrypt the information. This key is also referred to as a one time pad; therefore, it is important to distinguish between the one time pad (a cryptographical technique) and a one time pad (a key which is used to encrypt and decrypt information).

The One Time Pad is largely derived from the Vernam cipher, which is named after Gilbert Vernam. The Vernam cipher utilized a perforated tape (one of the earliest types of data storage) as the secret key\cite{VernamPatent}. Each bit of data was stored in the form of a hole punched into the perforated tape.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{PerforatedTape}
\caption{Perforated tape, utilized to store bits as punched holes}
\end{figure}

However, this system had a vulnerability which the One-Time Pad solved: In Vernam's original method, the perforated tape was not exchanged after it had completed one cycle; instead, it was looped around continuously, often being used to encrypt multiple different messages.

This made the entire system vulnerable. The re-usage of the key meant that the resulting ciphertext suffered from a so-called known-plaintext vulnerability \cite{HutSix}. This means that, if a plaintext and its corresponding ciphertext are captured, the key utilized to generate the ciphertext can be derived from them. This is not an issue if the key is exchanged each time a new message is encrypted. However, if the key of any Vernam cipher machine was compromised through a known-plaintext attack, any further intercepted ciphertexts could be decrypted.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{VernamCipher.jpg}
\caption{A technical diagram from Vernam's famous "Secret signaling system" patent of 1919.}
\end{figure}    

\section{Method used}
%This section, especially the practical example, is the most important part of the chapter.
In the following section, the utilized method will be clarified through usage of an example. In this example, the message \textit{"cryptography"} will first be encrypted by its sender, sent to its intended recipient, and finally decoded by the recipient.

\subsection{Generation of the random key}
In order to encrypt the plaintext, a key must first be generated. This key will be utilized to encrypt the plaintext through the usage of modular addition, turning it into the ciphertext.

This key must fulfil some crucial criteria \cite{MilsElectronic}. Foremost, the length of the key (the amount of  characters contained within it) must be equivalent to or greater than the length of the plaintext; otherwise, it is not possible to perform any encryption (using the OTP). Secondly, the key must be generated randomly. This is mainly due to the fact that a randomly generated key makes frequency analysis\cite{FrequencyAnalysis}, the form of cryptanalysis most commonly used to break classical ciphers, impossible.

% It's not clear what it means to generate a key randomly. 

The key consists of numbers. Usually, when the plaintext is made up of Latin letters, the numbers range between 0 and 25. The key can be converted into Latin letters through the same method applied to the plaintext outlined in the following chapter, however, this is not necessary, although the key is often transported in the form of text.

As the message being encrypted in this example has 12 characters, the key must also posses at least 12 characters. For the sake of this example, the key \textit{"sytruifgnihm"} will be utilized.

\subsection{Modular addition of the key and plaintext}
%unsure if a picture explaining modular addition and subtraction is needed, or if the provided explanation suffices?			

% In my opinition, the part about modular addition is quite clear. You could
% also add a binary example where you don't even need the concept of modular
% addition since all you need is an XOR gate - which of course is the same as
% modular addition of bits - but easier to understand.


Next, the ciphertext is created through modular addition of the key and the plaintext. This can be applied not only to a message consisting of alphabetical characters, but also to any sequence of bits. If the plaintext consists of a message made up of alphabetical characters, the plaintext and the key are added using arithmetic referred to as \textit{"addition modulo 26"}. The correct mathematical notation for modular arithmetic is $(a+b)\:mod\:c$, where c is referred to as the \textit{modulus}, which is the value that cannot be passed nor reached in modular addition. In order to perform modular addition, the variables a and b are first added, after which they are divided by the modulus c, up to an integer. The resulting remainder r is the final result of the operation.

Before the modular addition of the plaintext and the key can begin, each character (of the plaintext as well as of the secret key, in the case that the key was generated as a string of Latin letters instead of as a sequence of numbers) must be converted to a number, corresponding to it's position in the Latin alphabet:

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table1.PNG}		
\end{figure}
%Do these tables suffice in aiding understanding the example, or 		                                             should I include more "graphical" explanations as well?

% I don't think this needs to get any more graphical. You could look into latex
% tables and math syntax for arrow to make the typesetting look a bit more
% consistent.

As the key was also generated in the form of characters, it too must be converted to a sequence of numbers:

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table2.PNG}
\end{figure}

Afterwards, the key and the plaintext are added together utilizing modular addition. Of course, all operations below are performed in \textit{mod 26}. Finally, the resulting numbers are converted to the character to which they correspond in the Latin alphabet. The resulting sequence of characters is referred to as the ciphertext.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table3.PNG}
\end{figure}

The modular addition of the plaintext and the key can also, however, be performed bitwise. This simply means that, instead of adding a message consisting of (up to) 26 different letters with a key (also consisting of up to 26 different letters), we simply add the bits of the plaintext (a computer file consisting of bits), which can assume the value of either 1 or 2, with the bits of the key. The bits are added in modulo 2. This process is referred to as XOR, one of the basic bitwise operations which can be performed directly by a computers central processor.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{XORgate.PNG}
\caption{The formula used by an XOR gate.}
\end{figure}

\subsection{Decoding of the ciphertext using the key}
Assuming the message has been delivered to the intended recipient, who must hold a copy of the secret key (which, as OTP is a symmetrical cryptographical method, is identical to the one utilized to create the ciphertext), the recipient can now decode the ciphertext in order to view the plaintext.

Since the ciphertext was created through the modular addition of the plaintext and the key, the recipient can utilize modular subtraction in order to view the plaintext. In order to do this, the recipient must subtract the key from the ciphertext in modulo 26, and convert the resulting numbers to Latin characters.  However, it is now also necessary for the numbers not to become negative. Fortunately, this is also made possible by modular arithmetic, as the values simply loop back around from 0 as well. Once again, all below operations are in \textit{mod 26}.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{Table4.PNG}
\end{figure}

Now, the message's journey is complete, having passed from plaintext into ciphertext, being transported to its intended recipient in the form of ciphertext, and finally being decoded and read by its recipient. 

\section{Perfect secrecy: Information-theoretical security}
An important characteristic of OTP is that the ciphertext convey no information at all in regards to the plaintext; this means that it is not possible to garner any information about the key nor the plaintext if one is in possession of the ciphertext \cite{PerfectSecrecy} \cite{HandbookOfAppliedCryptography}.

From this, two other important characteristics of a cryptographical system with perfect secrecy can be derived. Firstly, perfect message indistinguishability. This means that, even if you are provided with multiple different plaintexts and one ciphertext, it is impossible to assign any one plaintext to the provided ciphertext. Secondly, if the key is the same length as the plaintext (as is the case in OTP), then there exists a key for every possible encryption from plaintext to ciphertext. This means that any plaintext can be converted to any ciphertext, making it impossible to determine the key without access to both the plaintext and the ciphertext. This is referred to as perfect key ambiguity.		%This paragraph was difficult for me to summarize well.

Although many believe that the ciphertext does provide information about the plaintext, namely its length, this can easily be solved through padding, where characters of no importance to the plaintext are added to it before encryption \cite{HutSix}.

\subsection{Mathematical proof}
%This is the section which was most difficult for me to write; I opted to present a more simplified explanation of %Shannons proof without the use of probability theory.
%Should I Include the probability Theory or is it better to keep it simple for the reader?

% I'm not convinced that you'll manage to present a mathematically correct proof without using
% any probability theory. There are a few problems with the current version of the proof: 


In 1949, Shannon proved the perfect secrecy of OTP by using probability theory \cite{ShannonOTP}. To be precise, he proved that, in order to achieve perfect secrecy, the key must possess at least the same length as the plaintext; one of the key characteristics of OTP. If this is the case, then an attacker cannot determine the plaintext given the ciphertext, even with access to infinite computational capacity; a "brute-force attack" is impossible.

% To proof that OTP provides perfect secrecy it's not enough to show that one
% can only achieve perfect secrecy with a key of the same length as the message
% as this is only a necessity but no sufficiency
% (https://en.wikipedia.org/wiki/Necessity_and_sufficiency) to achieve perfect
% secrecy. E.g. if I use the key consisting of as many zeros as the message has
% letters and encrypt every message by adding said key, the encryption gives you
% no secrecy at all even though the key has the same length as the message.


A simplified method of presenting this proof is as follows:

If the attacker does indeed possess infinite computational capacity, he can generate every possible key which could have been used to generate the ciphertext, and he can then generate every possible plaintext (each of which will correspond to the given ciphertext and one of the generated keys).

% I don't understand the comment in brackets. You could use a graphical explanation or mathematical
% notation to make your point clearer.

It follows that, if the ciphertext was $m$ bits long, there would be $2^m$ possible keys (or, in the case that the plaintext and ciphertext consist of Latin characters, $26^m$ possible keys). This is because a bit can possess the value of either 0 or 1, meaning that each individual bit of the key has two possible values. As The entire key possesses m bits, each cell must be multiplied by the following cell in order to obtain the total number of possible keys. In the case that the key consists of Latin characters, however, each cell possess 26 possible values (ranging from 0 to 25); therefore, the total number of possible keys would be $26^m$.

If the possible amount of keys that the attacker can generate is equal to $2^m$, and the attacker can generate one possible plaintext for each key, that means that the amount of plaintexts which the attacker can generate is also equal to $2^m$ (or, once again, in the case of Latin characters, equal to $26^m$ plaintexts).

This amount, $2^m$, is equal to the amount of possible bit sequences of the length m; therefore, the attacker cannot possibly eliminate any one possible plaintext of the length m, meaning that he cannot garner any information from the ciphertext on its own. This fulfils the requirements of perfect secrecy.

% We should discuss the above paragraphs in a meeting as I don't fully
% understand what you are trying to say. I'm not convinced that this suffices to
% proof perfect secrecy. Most importantly, it appears that you never used the
% randomness of the key in your proof. That's also the point where it gets
% difficult to avoid probability theory. Without probability theory you don't
% have a understanding of what it means for a key to be ``random''.

\subsection{Why can only OTP achieve perfect secrecy?}
%Not sure if this information warrants its own section or if I should merge it with the above one

From the above proof, it can be concluded that, in order for the elimination of any possible plaintext to be impossible (rendering a brute-force attack impossible), the key must possess at least the same length as the plaintext. Also, the individual bits of the must not be dependant on one another. These conditions are only fulfilled by OTP.  

\section{Issues with OTP}
%I had just one sentence here, but felt it appeared strange to just have one sentence and opted to leave it blank.
\subsection{True randomness in generating the key}
One of the most important aspects of the utilized key is that it must be completely random (see 1.2.1). However, generating a random sequence of numbers or letters is no trivial task. In fact, most random number generation functions of even modern programming languages are not adequately random for use in cryptography. This is especially difficult for computers, considering that a computer is, in essence, designed to follow a set of predictable instructions as quickly as possible.

Therefore, in order to generate a sufficiently random key, it is preferable to utilize hardware random number generators, for example by utilizing a true random noise source \cite{MilsElectronic}. One such example is the key generator built by mils electronic, where a set of parallel ring oscillators are sampled. Because the oscillation speed of each ring is influenced by random factors such as local variations in temperature and voltage.

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{MilsElectronic.PNG}
\caption{A hardware random number generator with sufficient randomness to be utilized in the generation of one-time pads.}
\end{figure}

\subsection{Secure distribution of the key itself}
The main issue in regards to OTP is that, while it posses perfect security, therefore solving the issue of safely transmitting the ciphertext, the problem instead becomes how to securely transmit the key to the intended recipient of the encrypted message.

Therefore, in order to ensure that the plaintext cannot be accessed by any party other than its intended recipient, the complete security of the transmittal of the key must also be ensured.

However, if the communicants already possess a method by which the key can be transmitted with infallible security, then it stands to reason that the plaintext itself could just as well be submitted through the same channel, considering that it has the same number of bytes (or characters) as the key. So, the problem of securely transmitting the plaintext has simply been transferred to the problem of securely transmitting the key.

One method of mitigating this issue is to first send one very long key, which can then be used for multiple messages in the future. Using this method, only one secure transmission has to be made in order to ensure the security of multiple transmissions. 

\subsection{Secure disposal of a utilized key}
%Once again, not entirely sure if this warrants its own section or if it should be merged into the above section.
After a key has been fully utilized, it has to be disposed of securely, in order to prevent any information from being compromised in the future, which is possible should the key continue to exist. Therefore, it is necessary to completely eradicate the entirety of the key. If the key was stored on a digital media, such as a USB drive or HDD, the only completely secure method of disposal is considered to be complete incineration.

% Whenever you use a sentence like ``is considered to be...'' you need to
% provide a source. Are you sure that incinerating hard drives does the job? The
% ways I know of used to destroy harddrives involve strong electromagnets and drills.

\chapter{AES: The Advanced Encryption Standard}

\section{AES viewed from a high level}

Viewed from a high level, the AES algorithm consists of one XOR step, followed by 10 rounds of cryptographical measures, with each round as well as the initial XOR step using a specific subkey, generated using the main key. By passing through these steps, each block of plaintext is converted into a block of Ciphertext. In the following chapter, each individual aspect of the complete AES algorithm will be more closely examined.

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{AES_fig1.jpg}
\caption{A high-level description of AES.}
\end{figure}

\section{Method used}
Each round possesses 4 steps, explained in detail below. However, before those operations can be understood, some basic terminology must first be clarified.

The "state" is the matrix containing the information which is manipulated throughout the encryption process. As such, the state begins its journey through AES as the block of plaintext which is to be encrypted, and ends it as a block of ciphertext. The state is represented in a 4x4 column-major order matrix; this means that, in a block containing 16 bytes, the standard size of an AES plaintext block as well as the standard size of an AES key $(16 bytes * 8 = 128 bits)$.

\[ \left( \begin{array}{cccc}
a_0 & a_4 & a_8 & a_{12} \\
a_1 & a_5 & a_9 & a_{13} \\
a_2 & a_6 & a_{10} & a_{14} \\
a_3 & a_7 & a_{11} & a_{15}\end{array} \right)\] 

It is important to note that, because the state is a column-major order matrix, the bytes are counted from "top to bottom"; that is, in the direction of the columns, and not in the direction of the rows. This shows how the bytes from the plaintext are ordered into the state. However, in order to clarify the manipulations performed throughout the 10 rounds of AES, it is more beneficial to note the starting position each byte takes in the subscript instead of noting its chronological order in the plaintext block.

\[ \left( \begin{array}{cccc}
a_{0,0} & a_{0,1} & a_{0,2} & a_{0,3} \\
a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} \\
a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} \\
a_{3,0} & a_{3,1} & a_{3,2} & a_{3,3}\end{array} \right)\] 

The subkey possesses the same size as the state, and is made into a matrix in the exact same fashion; this is, of course, necessary for the successful modular addition of the bytes contained within the state and those contained within the subkey using the XOR operation.


\subsection{Initial XOR operation}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{AES_fig2.jpg}
\end{figure}

This step is identical to the XOR operation already described in the chapter regarding OTP; once again, a simple XOR gate is used to add the state with the initial XOR operations own subkey (which, crucially, is not the main key itself, but is, in fact, derived from the main key during the process of subkey generation).

\[ 
\left( \begin{array}{cccc}
a_{0,0} & a_{0,1} & a_{0,2} & a_{0,3} \\
a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} \\
a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} \\
a_{3,0} & a_{3,1} & a_{3,2} & a_{3,3}\end{array} \right)
+
\left( \begin{array}{cccc}
k_{0,0} & k_{0,1} & k_{0,2} & k_{0,3} \\
k_{1,0} & k_{1,1} & k_{1,2} & k_{1,3} \\
k_{2,0} & k_{2,1} & k_{2,2} & k_{2,3} \\
k_{3,0} & k_{3,1} & k_{3,2} & k_{3,3}\end{array} \right)
\]

Here, each byte of the state is combined with the byte of the subkey which possesses the corresponding position using the XOR operation. For example, $a_{2,1}$ would be combined with $k_{2,1}$. The resulting byte is then placed at the matching coordinate (in this example, once again the coordinate 2,1) of the resulting matrix. The completed matrix resulting from this operation is the new state. Next, this resulting state proceeds into the first of ten so-called "rounds".

\subsection{Rounds}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{AES_fig3.jpg}
\end{figure}

\subsubsection{Galois Field $GF(2^8)$ arithmetic}
Before the math behind AES can be fully understood, the Galois Field $GF(2^8)$ must first be more closely examined. This field contains only 256 values, ranging from 0-255; the range which can be stored in a byte. Secondly, all bytes are written using hexadecimal notation. Most importantly, all binary strings are represented as polynomials; this is best illustrated through an example \cite{GFieldExample}.

$11001000 = x^7+x^6+x^3$

$10000111 = x^7+x^2+x+1$

Addition is made rather simple through this; keeping in mind that, since addition is an XOR operation, two identical factors neutralize each other $(x^n+x^n = 0)$.

$(x^7+x^6+x^3)+(x^7+x^2+x+1) = x^6+x^3+x^2+x+1 = 01001111 = 4f$

As can be seen, this method is in keeping with the XOR addition of bytes. However, multiplication within the field is not quite as simple.

The issue with multiplying two bytes with each other within the finite field is that it is possible to receive a polynomial of higher order than 7; polynomials like this cannot be stored as a byte. Therefore, a reducing polynomial of the order 8 must be utilized. AES defines this reducing polynomial as $x^8+x^4+x^3+x+1$. The Galois Field $GF(2^8)$ utilizing the reducing polynomial $x^8+x^4+x^3+x+1$ for multiplication is referred to as Rijndael's finite field\cite{RFiniteField}.

In order to prevent a result that cannot be stored as a byte, all results of multiplications between bytes are then taken modulo the reducing polynomial. This means that, if the degree of a resulting polynomial exceeds 7, an XOR division using the reducing polynomial must be performed.

\subsubsection{Substitution using lookup table (SUBBYTES)}
The first substitution is relatively simple to perform; this is because it is a bytewise operation. This means that the data being manipulated is one single byte. In this case, the manipulation is a substitution of each byte with another byte, the substitution being determined by a lookup table, in which each individual byte is assigned another byte with which it must be swapped. The reason that a lookup table is practical is that there are only $2^8 = 256$ different possible bytes.

This swapping of bytes is performed using a Rijndael S-box as the lookup table. Firstly, it is very important to note that this substitution is performed in a Galois field (also referred to as a finite field)\cite{GaloisField}, specifically $GF(2^8)$.

The S-Box performs a revertible, complete transformation of the plaintext\cite{SBox}. This means that the transformation is reversible (which is necessary for decryption), and that no two different bytes are transformed into the same byte; this is the criteria for a full permutation.

In practice, the table is pre-calculated, since it is the same for each byte. Therefore, the most simple method of performing this substitution is to first split the byte into two 4-bit nibbles. If the byte is represented in hexadecimal, then the first nibble is simply the first of the two values, the second nibble being the second of the two values. For example, the byte $(7c)_h$, $(01111100)_2$ in binary, would be converted to the byte $(c6)_h$.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{SBox.PNG}
\caption{The lookup table used for AES, in hexadecimal notation\cite{SBox}.}
\end{figure}

First, the multiplicative inverse of the byte is calculated within Rijndael's finite field. This multiplicative inverse, also a byte, is then stored as a vector $[x_7; x_6 ... x_0]$ to be used in an affine transformation. As always, it is important to note that the plus sign denotes an XOR operation.

\[ \left( \begin{array}{cccccccc}
1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\
1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1\end{array} \right)
*
\left( \begin{array}{c}
x_0 \\
x_1 \\
x_2 \\
x_3 \\
x_4 \\
x_5 \\
x_6 \\
x_7\end{array} \right)
+
\left( \begin{array}{c}
1 \\
1 \\
0 \\
0 \\
0 \\
1 \\
1 \\
0\end{array} \right)
=
\left( \begin{array}{c}
b_0 \\
b_1 \\
b_2 \\
b_3 \\
b_4 \\
b_5 \\
b_6 \\
b_7\end{array} \right)
\]

So, after being manipulated by the S-Box, the byte of the state is replaced by the byte $[b_7; b_6 ... b_0 ]$. This step is performed for each of the 16 bytes in the state. After each byte of the state has been replaced, the new state continues on to the ShiftRows step.



\subsubsection{Transposition (SHIFTROWS)}
The next operation, transposition, operates upon the rows of the state by shifting each byte by a certain offset. The offset starts with 0, and is then increased by 1 for each row downwards from the top row.

\[ \left( \begin{array}{cccc}
a_{0,0} & a_{0,1} & a_{0,2} & a_{0,3} \\
a_{1,0} & a_{1,1} & a_{1,2} & a_{1,3} \\
a_{2,0} & a_{2,1} & a_{2,2} & a_{2,3} \\
a_{3,0} & a_{3,1} & a_{3,2} & a_{3,3}\end{array} \right)
\xrightarrow{ShiftRows}
\left( \begin{array}{cccc}
a_{0,0} & a_{0,1} & a_{0,2} & a_{0,3} \\
a_{1,1} & a_{1,2} & a_{1,3} & a_{1,0} \\
a_{2,2} & a_{2,3} & a_{2,0} & a_{2,1} \\
a_{3,3} & a_{3,0} & a_{3,1} & a_{3,2}\end{array} \right)
\]

\subsubsection{Substitution using formula (MIXCOLUMNS)}
The MixColumns step replaces each byte in the state with a different byte, dependent on all the bytes of that same column. Once again, it is important to note that all multiplications are performed within Rijndael's finite field.

In the MixColumns step, each column (and crucially not each individual byte) is treated as a polynomial in Rijndael's finite field.

MixColumns can be performed by multiplying the column (treated as a vector) with a circulant (meaning that each row of the matrix is identical to the one above it, except that the values are offset by 1 to the right) MDS ("maximum distance separable", a representation of a function known to have useful properties in cryptography) Matrix \cite{MixColumns}.

It is very important to note that the values of the cyclical MDS matrix are not regular numbers, but actually represent hexadecimal bytes (for example, $03 = 11$, which is then padded with zeroes until it possesses 8 values, making it 00000011. This is permissible in Rijndael's finite field, as $11 = x+1 = 00000011$)

\[ \left( \begin{array}{cccc}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02\end{array} \right)
*
\left( \begin{array}{c}
a_0 \\
a_1 \\
a_2 \\
a_3\end{array} \right)
=
\left( \begin{array}{c}
s_0 \\
s_1 \\
s_2 \\
s_3\end{array} \right)
\]

Now, it becomes evident that each byte of the resulting column is dependent on every byte of the manipulated column. As always, all operations take place in Rijndael's finite field. \\
\\
$
s_0 = {02}*a_0+{03}*a_1+{01}*a_2+{01}*a_3 \\
s_1 = {01}*a_0+{02}*a_1+{03}*a_2+{01}*a_3 \\
s_2 = {01}*a_0+{01*}a_1+{02}*a_2+{03}*a_3 \\
s_3 = {03}*a_0+{01}*a_1+{01}*a_2+{02}*a_3 \\ $

It is important to note that the last round of AES does not possess a MixColumns step; this is because, if there were a MixColumns step included in the last round of encryption, it would not possess a corresponding invMixColumns in the final round of decryption\cite{NoMixColumns}.
\subsubsection{Subkey generation (KEYEXPANSIONS)}
As can be seen in the high-level explanation, AES requires 11 128-bit subkeys (also referred to as round keys); one for the initial XOR operation, and then one for each of the 10 rounds. These subkeys are derived from the main key using the "Rijndael key schedule" \cite{KeySchedule}.


The first round key, utilized for the initial XOR operation, is simply the master key itself.

\[ \left( \begin{array}{cccc}
k_0 & k_4 & k_8 & k_{12} \\
k_1 & k_5 & k_9 & k_{13} \\
k_2 & k_6 & k_{10} & k_{14} \\
k_3 & k_7 & k_{11} & k_{15}\end{array} \right)\] 

Each subsequent round key must be generated through key expansion.

The first four bytes of the 16-byte round key, which are contained within the first column of the round key matrix, are generated first. To this end, the last, as in the rightmost, column is stored in a temporary variable, for example x. The so-called RotWord operation is then employed, wherein each byte is transposed one step upwards.

\[
\left( \begin{array}{c}
x_0 \\
x_1 \\
x_2 \\
x_3\end{array} \right)
\xrightarrow{RotWord}
\left( \begin{array}{c}
x_1 \\
x_2 \\
x_3 \\
x_0\end{array} \right)
\]

Afterwards, the four bytes resulting from the RotWord operation are each replaced through utilization of a Rijndael S-Box (see chapter 2.2.2.2). The resulting vector now needs to be added to the first, as in the leftmost, column of the master key using an XOR gate.

\[
\left( \begin{array}{c}
x_1 \\
x_2 \\
x_3 \\
x_0\end{array} \right)
\xrightarrow{SubBytes}
\left( \begin{array}{c}
b_0 \\
b_1 \\
b_2 \\
b_3\end{array} \right)
+
\left( \begin{array}{c}
k_0 \\
k_1 \\
k_2 \\
k_3\end{array} \right)
\]

The final step to obtain the first four bytes of the round key is referred to as the RCon, meaning round constant \cite[p. 15]{Rijndael} step. In this step, a vector dependent on the iteration, the chronological number of the round key being generated starting with one, is added using an XOR gate. These vectors are constant for every application of AES; for example, the RCon vector obtained using an iteration of eight will always be used in the process of obtaining the first four bytes of the eighth round key.

The RCon vector is calculated through the following formula, with i standing for the iteration:

\[ \left( \begin{array}{c}
{02}^{i-1}\\
00 \\
00 \\
00\end{array} \right) \]

As this operation takes place in Rijndael's finite field, the byte ${02} = x$, and if the RCon value possesses an order higher than 7, it must be taken modulo the reducing polynomial (see chapter 2.2.2.1). After the RCon operation is complete, the first column of the round key has been obtained.

The generation of the other three columns is now relatively simple; only the XOR operation is necessary from this point onwards. In order to obtain the second column of the round key, the first column of the round key is added to the second column of the master key. The second column of the round key is now added to the third column of the master key in order to obtain the third column of the round key. Finally, in order to obtain the fourth column of the round key, the fourth column of the master key is added to the third column of the round key.

\[ \left( \begin{array}{cccc}
r_0 & r_4=r_0+k_4 & r_8=r_4+k_8 & r_{12}=r_8+k_{12} \\
r_1 & r_5=r_1+k_5 & r_9=r_5+k_9 & r_{13}=r_9+k_{13} \\
r_2 & r_6=r_2+k_6 & r_{10}=r_6+k_{10} & r_{14}=r_{10}+k_{14} \\
r_3 & r_7=r_3+k_7 & r_{11}=r_7+k_{11} & r_{15}=r_{11}+k_{15}\end{array} \right) \]

This round key is taken as the master key for the generation of the next round key. This process is then repeated until ten new keys have been generated.

\subsubsection{Round-closing XOR operation (ADDROUNDKEY)}
Finally, the state is added to the round's unique round key using modular addition. The method is the same as described in chapter 2.2.2; an XOR gate is, once again, utilized.

\section{Fulfilment of Shannon's properties}
In 1945, Claude Shannon wrote a report that would become central to cryptography. This report was titled "A Mathematical Theory of Cryptography", and it identified two properties necessary to ensure the security of any cipher\cite{ShannonProperties}. These were termed diffusion and confusion. These two properties, if fulfilled, serve to make methods of cryptanalysis, in particular statistical analysis, less effective.

\subsection{Diffusion}
Diffusion requires that, as a rule of thumb, changing one bit of the plaintext should alter half of the ciphertext, with the reverse also being true; this is referred to as the avalanche effect\cite{AvalancheEffect}. This is best achieved by spreading the values of the plaintext out over the entire ciphertext; hence the term "diffusion".

In AES, diffusion is  provided by the MixColumns and the Shiftrows steps. The diffusion provided by the ShiftRows step is self-evident; as the bytes are entered into the state in a column-major order, mixing the bytes along the rows is a good source of diffusion.

MixColumns is a good source of diffuion because it creates a dependecy of four bytes on just one byte; if a single byte of the four substituted bytes are changed, every byte resulting from the substitution is also changed. This effect is further compounded because it is performed nine times, meaning that if just one bit, contained within a byte, of the initial plaintext is altered, the ciphertext will be dramatically different.

\subsection{Confusion}
Confusion requires that each bit of the ciphertext relies on multiple different parts of the key. This means that the input data must be altered in a non-linear, difficult to reverse manner, thereby obscuring the relation between the ciphertext and the key\cite{Confusion}.

In AES, confusion is provided by the SubBytes step. This can be seen if the journey of a single byte through AES is examined; Since each byte goes through so many substitutions, it is difficult to find the key even if one were to possess a large number of plaintext-ciphertext pairs.

\section{Problems with AES}
In 1997, NIST deemed it necessary to replace DES, the data encryption standard, with AES, the advanced encryption standard, because of DES' vulnerability to brute force attacks due to its small key size. 15 submissions were received, but Rijndael was selected due to its good performance and security\cite{AESSelection}.

Though AES was thouroughly vetted during the AES selection process and is considered secure enough to be used in encryption of top secret documents by the National Security Agency\cite{CNSSPolicy} of the united states, it is unfortunately not perfect.

\subsection{Overconfidence and over-reliance}
AES is widely used by large businesses and the United States government. Therefore, it would be a large threat to many nations national security if the Cipher were to be compromised.

One of the earliest scares was the XSL attack, which relied on the relative algebraic simplicity of AES\cite{XSL}.However, this proposed attack was later shown to be technically infeasible\cite{XLSRebuked}; nevertheless, this shows that while AES is very secure, the cryptographic community must remain vigilant in its continued research into possible attacks in order to ensure the security of highly sensitive data across the world.

\subsection{Keeping of a shared secret}
One of AES' major issues is shared with OTP and all other symmetric-key encryption methods; the confidentiality of the key. The same argument that was made against OTP can be made against AES as well, namely that because the encryption method as well as the decryption method are both publicly known, the problem of keeping the message or file secret is simply transferred to keeping the key secret, while still being able to exchange it between the sender and the recipient.

However, in the case of AES, this issue is strongly mitigated: While the key used in OTP has to be at least as long as the message, AES keys are only 128, 192 or 256 bits long, with top secret documentation requiring the usage of either a 192 or 256-bit key\cite{CNSSPolicy}.

% have to print the bibliography once all entries are made, otherwise an error keeps occuring.
\printbibliography

\end{document}

